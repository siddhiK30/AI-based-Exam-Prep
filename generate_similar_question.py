# -*- coding: utf-8 -*-
"""generate_Similar_Question.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IpS3eAqoaezt4OPn5d4hROjYYLRSQgfX
"""

pip install openai

import os
import google.generativeai as genai

# Configure the Gemini API key

os.getenv('GEMINI_API_KEY')

# Initialize the GenerativeModel with the 'gemini-1.5-flash' version
model = genai.GenerativeModel("gemini-1.5-flash")


def generate_similar_question(original_question_html):
    # Stage 1: Rephrase the original question with different values while maintaining the same structure and type of problem
    prompt = (f"Generate a math question similar to the following by rephrasing and changing values, "
              f"Ensure the new question has different numeric values:\n{original_question_html}")
    response = model.generate_content(prompt)
    similar_question_html = response.text
    return similar_question_html

def generate_solution_for_question(question_html):
    # Stage 2: Solve the math question step-by-step with detailed explanations for each operation
    prompt = (f"Solve the following math question step-by-step. Explain each step clearly and "
              f"provide the final answer at the end in HTML format. Each step should be described in detail:\n{question_html}")
    response = model.generate_content(prompt)
    solution_html = response.text
    return solution_html

def verify_and_correct_solution(question_html, solution_html):
    # Stage 3: Verify the solution step-by-step and correct any errors, providing the accurate solution
    prompt = (f"Check the solution below for the given math question. If any steps are incorrect, correct them and "
              f"provide the accurate solution, with detailed explanations for each step in HTML format:\n"
              f"Question:\n{question_html}\nSolution:\n{solution_html}")
    response = model.generate_content(prompt)
    verified_solution_html = response.text
    return verified_solution_html

def math_pipeline():
    # Take user input for the original math question
    original_question_html = input("Enter the original math question in HTML format:\n")

    # Stage 1: Generate a similar question with different values
    similar_question_html = generate_similar_question(original_question_html)
    print("\nGenerated Similar Question:")
    print(similar_question_html)

    # Stage 2: Generate the solution for the similar question with detailed steps
    solution_html = generate_solution_for_question(similar_question_html)
    print("\nGenerated Solution with Detailed Steps:")
    print(solution_html)

    # Stage 3: Verify and correct the solution if necessary
    verified_solution_html = verify_and_correct_solution(similar_question_html, solution_html)
    print("\nVerified and Corrected Solution (if needed):")
    print(verified_solution_html)

# Execute the math pipeline
math_pipeline()

pip install groq

import os
from groq import Groq


# Load the Groq API key from environment variables
api_key = os.getenv('GROQ_API_KEY')
client = Groq(api_key=api_key)

def generate_similar_question(original_question_html):
    """Generates a similar question by rephrasing the original question with new values."""
    chat_completion = client.chat.completions.create(
        messages=[{
            "role": "user",
            "content": f"Please rephrase the following math question with different numerical values but maintain the same structure. Ensure the values are reasonable and realistic. Output the new question in HTML format:\n{original_question_html}",
        }],
        model="llama3-70b-8192",
    )

    new_question_html = chat_completion.choices[0].message.content.strip()
    print("Generated Question:", new_question_html)  # Log generated question
    return new_question_html

def generate_solution(new_question_html):
    """Generates a solution for the new math question."""
    chat_completion = client.chat.completions.create(
        messages=[{
            "role": "user",
            "content": f"Solve this math question and provide the answer with the full step-by-step solution in HTML format. Ensure the solution is correct and formatted properly:\n{new_question_html}",
        }],
        model="llama3-70b-8192",
    )

    solution_html = chat_completion.choices[0].message.content.strip()
    print("Generated Solution:", solution_html)  # Log generated solution
    return solution_html

def verify_solution(new_question_html, generated_solution_html):
    """Verifies if the generated solution is correct for the given question."""
    chat_completion = client.chat.completions.create(
        messages=[{
            "role": "user",
            "content": f"Please verify if the following solution is correct for the given math question in HTML format. Point out any errors or confirm correctness.\nQuestion: {new_question_html}\nSolution: {generated_solution_html}",
        }],
        model="llama3-70b-8192",
    )

    verification_result = chat_completion.choices[0].message.content.strip()
    print("Verification Result:", verification_result)  # Log verification result
    return verification_result

def correct_solution(new_question_html, generated_solution_html):
    """Corrects the generated solution if there are errors."""
    chat_completion = client.chat.completions.create(
        messages=[{
            "role": "user",
            "content": f"The following solution contains errors. Please correct the mistakes, provide the accurate solution, and explain where the errors occurred. Output everything in HTML format.\nQuestion: {new_question_html}\nIncorrect Solution: {generated_solution_html}",
        }],
        model="llama3-70b-8192",
    )

    corrected_solution = chat_completion.choices[0].message.content.strip()
    print("Corrected Solution:", corrected_solution)  # Log corrected solution
    return corrected_solution

# Main pipeline function
def math_question_pipeline(original_question_html):
    """Main function to handle the math question processing pipeline."""
    # Stage 1: Generate similar question
    new_question_html = generate_similar_question(original_question_html)

    # Validate generated question structure here if needed
    # (Optional: Add checks for the structure of the rephrased question)

    # Stage 2: Generate answer and solution for the new question
    solution_html = generate_solution(new_question_html)

    # Stage 3: Verify the solution
    verification_result = verify_solution(new_question_html, solution_html)

    # If the solution is incorrect, correct it
    if "incorrect" in verification_result.lower():
        corrected_solution = correct_solution(new_question_html, solution_html)
        print("Final Corrected Solution:", corrected_solution)  # Final corrected solution log
        return new_question_html, corrected_solution
    else:
        print("Solution is correct.")  # Solution validation log
        return new_question_html, solution_html

# Example usage
if __name__ == '__main__':
    # Get the question from user input
    original_question_html = input("Enter the original math question in HTML format: ")

    # Run the pipeline
    question, solution = math_question_pipeline(original_question_html)

    # Log final outputs
    print("Final Question:", question)
    print("Final Solution:", solution)